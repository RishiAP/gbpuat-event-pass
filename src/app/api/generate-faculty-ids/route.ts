import puppeteer from 'puppeteer';
import chromium from '@sparticuz/chromium';
import { NextRequest, NextResponse } from 'next/server';
import { User } from '@/models/User';
import { getFacultyIdHTML } from '@/helpers/templateService';
import { connect } from '@/config/database/mongoDBConfig';
import { Event } from '@/models/Event';
import { getUserFromHeader } from '@/helpers/common_func';
import { College } from '@/models/College';
import { Department } from '@/models/Department';
import { Verifier } from '@/models/Verifier';
import { uploadJpg } from '@/lib/cloudinary';

connect();

College;
Department;

// Configuration constants
const CONFIG = {
  BATCH_SIZE: 30,
  CONCURRENT_PAGES: 5,
  CONTENT_TIMEOUT: 30000,
  RENDER_DELAY: 1000,
  JPG_QUALITY: 100,
  JPG_DPI_SCALE: 1,
  CARD_WIDTH: 1181,
  CARD_HEIGHT: 756,
  SCREENSHOT_TIMEOUT: 15000,
} as const;

// ──────────────────────────────────────────────────────────────
// UTILITIES
// ──────────────────────────────────────────────────────────────
const delay = (ms: number) => new Promise(r => setTimeout(r, ms));

// ──────────────────────────────────────────────────────────────
// PROCESS SINGLE FACULTY
// ──────────────────────────────────────────────────────────────
const processFaculty = async (
  browser: any,
  user: any,
  event: any
) => {
  const page = await browser.newPage();
  
  try {
    await page.setViewport({
      width: CONFIG.CARD_WIDTH,
      height: CONFIG.CARD_HEIGHT,
      deviceScaleFactor: CONFIG.JPG_DPI_SCALE,
    });

    const html = await getFacultyIdHTML(event, user);
    
    await page.setContent(html, { 
      waitUntil: 'networkidle0', 
      timeout: CONFIG.CONTENT_TIMEOUT 
    });
    
    await delay(CONFIG.RENDER_DELAY);

    const jpgBuffer = await page.screenshot({
      type: 'jpeg',
      quality: CONFIG.JPG_QUALITY,
      clip: { 
        x: 0, 
        y: 0, 
        width: CONFIG.CARD_WIDTH, 
        height: CONFIG.CARD_HEIGHT 
      },
      timeout: CONFIG.SCREENSHOT_TIMEOUT,
    });

    // Upload to Cloudinary
    const collegeName = user.college?.name || 'No College';
    const filename = `${user.name} - ${user.email}`;
    const url = await uploadJpg(jpgBuffer as Buffer, event.title, collegeName, filename);

    // Update database
    await User.findByIdAndUpdate(user._id, {
      $set: { [`events.${event._id.toString()}.id_card`]: url },
    });

    console.log(`✓ ${user.email}`);
    
    return { success: true, email: user.email };
  } catch (error: any) {
    console.error(`✗ ${user.email}:`, error);
    return { 
      success: false, 
      email: user.email, 
      error: error.message || 'Unknown error' 
    };
  } finally {
    await page.close();
  }
};

// ──────────────────────────────────────────────────────────────
// BATCH PROCESSOR
// ──────────────────────────────────────────────────────────────
const processBatch = async (
  users: any[],
  event: any,
  concurrentPages: number
) => {
  const browser = await puppeteer.launch({
    args: [...chromium.args, '--no-sandbox', '--disable-setuid-sandbox'],
    executablePath: await chromium.executablePath(),
    headless: true,
  });

  const batchResults = {
    successful: 0,
    failed: 0,
    errors: [] as Array<{ email: string; error: string }>
  };

  try {
    for (let i = 0; i < users.length; i += concurrentPages) {
      const chunk = users.slice(i, i + concurrentPages);
      
      console.log(`  Processing ${chunk.length} faculties (${i + 1}-${i + chunk.length}/${users.length})`);
      
      const results = await Promise.all(
        chunk.map(user => 
          processFaculty(browser, user, event)
        )
      );

      for (const result of results) {
        if (result.success) {
          batchResults.successful++;
        } else {
          batchResults.failed++;
          batchResults.errors.push({ 
            email: result.email, 
            error: result.error || 'Unknown error' 
          });
        }
      }
    }
  } finally {
    await browser.close();
  }

  return batchResults;
};

// ──────────────────────────────────────────────────────────────
// ATOMIC INCREMENT HELPER
// ──────────────────────────────────────────────────────────────
const incrementIdCardGenerated = async (eventId: string, count: number) => {
  try {
    await Event.findByIdAndUpdate(
      eventId,
      { $inc: { id_card_generated: count } },
      { new: false }
    );
    console.log(`✓ Incremented id_card_generated by ${count}`);
  } catch (error) {
    console.error('Error incrementing id_card_generated:', error);
  }
};

// ──────────────────────────────────────────────────────────────
// MAIN POST HANDLER
// ──────────────────────────────────────────────────────────────
export async function POST(request: NextRequest) {
  try {
    const admin = await getUserFromHeader(request, true);
    if (admin == null) {
      return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
    }
    
    const { event_id } = await request.json();
    
    if (!event_id) {
      return NextResponse.json({ message: "Event ID required" }, { status: 400 });
    }
    
    if (CONFIG.CONCURRENT_PAGES > CONFIG.BATCH_SIZE) {
      throw new Error('CONCURRENT_PAGES cannot be greater than BATCH_SIZE');
    }

    const event = await Event.findById(event_id).select('title');
    if (!event) {
      return NextResponse.json({ message: "Event not found" }, { status: 404 });
    }

    // Find faculties
    const faculties = await User.find({
      $and: [
        {
          $or: [
            { college_id: null },
            { college_id: { $exists: false } }
          ]
        },
        {
          [`events.${event_id}`]: { $exists: true, $ne: null }
        },
        {
          $or: [
            { [`events.${event_id}.id_card`]: { $exists: false } },
            { [`events.${event_id}.id_card`]: null },
            { [`events.${event_id}.id_card`]: '' }
          ]
        }
      ]
    })
      .populate('college')
      .populate('department');

    // Fetch and map verifiers
    const allVerifiers = await Verifier.find({});
    const verifierMap = new Map(
      allVerifiers.map(v => [v._id.toString(), v])
    );

    for (const faculty of faculties) {
      const eventData = faculty.events.get(event_id);
      if (eventData?.verifier) {
        const verifierId = typeof eventData.verifier === 'object' 
          ? eventData.verifier._id.toString() 
          : eventData.verifier.toString();
        
        const verifierDoc = verifierMap.get(verifierId);
        if (verifierDoc) {
          eventData.verifier = verifierDoc;
          faculty.events.set(event_id, eventData);
        }
      }
    }

    const totalFaculties = faculties.length;

    if (totalFaculties === 0) {
      return NextResponse.json({ 
        message: "No faculties to process", 
        total: 0,
        successful: 0,
        failed: 0
      });
    }

    console.log(`Found ${totalFaculties} faculties for event: ${event.title}`);
    console.log(`Config: BATCH=${CONFIG.BATCH_SIZE}, CONCURRENT=${CONFIG.CONCURRENT_PAGES}`);
    console.log(`Storage: Cloudinary`);

    // SSE Stream
    const encoder = new TextEncoder();
    const stream = new ReadableStream({
      async start(controller) {
        try {
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({
            status: 'started',
            total: totalFaculties,
            eventTitle: event.title,
            config: {
              batchSize: CONFIG.BATCH_SIZE,
              concurrentPages: CONFIG.CONCURRENT_PAGES
            }
          })}\n\n`));

          let totalProcessed = 0;
          let totalSuccessful = 0;
          let totalFailed = 0;
          const allErrors: Array<{ email: string; error: string }> = [];

          const totalBatches = Math.ceil(totalFaculties / CONFIG.BATCH_SIZE);

          for (let i = 0; i < totalFaculties; i += CONFIG.BATCH_SIZE) {
            const batch = faculties.slice(i, i + CONFIG.BATCH_SIZE);
            const batchNumber = Math.floor(i / CONFIG.BATCH_SIZE) + 1;
            
            console.log(`\nBatch ${batchNumber}/${totalBatches} (${batch.length} faculties)`);
            
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({
              status: 'batch_started',
              batch: batchNumber,
              totalBatches: totalBatches,
              batchSize: batch.length
            })}\n\n`));
            
            const batchResults = await processBatch(
              batch,
              event,
              CONFIG.CONCURRENT_PAGES
            );
            
            totalProcessed += batch.length;
            totalSuccessful += batchResults.successful;
            totalFailed += batchResults.failed;
            allErrors.push(...batchResults.errors);
            
            if (batchResults.successful > 0) {
              await incrementIdCardGenerated(event_id, batchResults.successful);
            }
            
            controller.enqueue(encoder.encode(`data: ${JSON.stringify({
              status: 'batch_complete',
              batch: batchNumber,
              totalBatches: totalBatches,
              batchSuccessful: batchResults.successful,
              batchFailed: batchResults.failed,
              totalProcessed: totalProcessed,
              totalSuccessful: totalSuccessful,
              totalFailed: totalFailed,
              percentage: ((totalProcessed / totalFaculties) * 100).toFixed(2),
              total: totalFaculties
            })}\n\n`));
            
            console.log(`Batch ${batchNumber}: ${batchResults.successful} OK, ${batchResults.failed} failed`);
          }

          controller.enqueue(encoder.encode(`data: ${JSON.stringify({
            status: 'complete',
            total: totalFaculties,
            successful: totalSuccessful,
            failed: totalFailed,
            errors: allErrors.slice(0, 10),
            percentage: '100.00',
            message: 'All Faculty ID JPGs generated!'
          })}\n\n`));

          console.log(`\n✓ Complete: ${totalSuccessful}/${totalFaculties} successful`);

        } catch (error: any) {
          console.error('Stream error:', error);
          controller.enqueue(encoder.encode(`data: ${JSON.stringify({
            status: 'error',
            message: error.message || 'Unknown error occurred'
          })}\n\n`));
        } finally {
          controller.close();
        }
      }
    });

    return new Response(stream, {
      headers: {
        'Content-Type': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive',
      },
    });

  } catch (error: any) {
    console.error('Error in POST request:', error);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}